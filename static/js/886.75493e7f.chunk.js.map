{"version":3,"file":"static/js/886.75493e7f.chunk.js","mappings":"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","sources":["services/filmService.ts","components/ui/Button.tsx","components/ui/Card.tsx","../node_modules/lucide-react/src/icons/clock.ts","services/voteService.ts","utils/helpers.ts","services/seanceService.ts"],"sourcesContent":["import { db } from './firebase';\nimport { \n  collection, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  getDocs, \n  getDoc, \n  query, \n  where, \n  orderBy,\n  limit\n} from 'firebase/firestore';\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';\nimport { Film, CreateFilmData } from '../types';\nimport { generateId } from '../utils/helpers';\n\nconst FILMS_COLLECTION = 'films';\nconst POSTERS_FOLDER = 'posters';\n\n/**\n * Créer un nouveau film avec upload du poster\n */\nexport const createFilm = async (data: CreateFilmData): Promise<Film> => {\n  try {\n    let posterUrl: string | undefined;\n\n    // Upload du poster si fourni\n    if (data.poster) {\n      posterUrl = await uploadPoster(data.poster);\n    }\n\n    const filmData: Omit<Film, 'id'> = {\n      titre: data.titre,\n      realisateur: data.realisateur,\n      pays: data.pays,\n      duree: data.duree,\n      annee: data.annee,\n      synopsis: data.synopsis,\n      genre: data.genre,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      ...(posterUrl && { posterUrl }),\n    };\n\n    const docRef = await addDoc(collection(db, FILMS_COLLECTION), filmData);\n    \n    return {\n      id: docRef.id,\n      ...filmData,\n    };\n  } catch (error) {\n    console.error('Erreur lors de la création du film:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer tous les films\n */\nexport const getAllFilms = async (): Promise<Film[]> => {\n  try {\n    const q = query(\n      collection(db, FILMS_COLLECTION),\n      orderBy('titre', 'asc')\n    );\n    \n    const querySnapshot = await getDocs(q);\n    const films: Film[] = [];\n    \n    querySnapshot.forEach((doc) => {\n      const data = doc.data();\n      films.push({\n        id: doc.id,\n        titre: data.titre,\n        realisateur: data.realisateur,\n        pays: data.pays,\n        duree: data.duree,\n        annee: data.annee,\n        synopsis: data.synopsis,\n        posterUrl: data.posterUrl,\n        genre: data.genre,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n    \n    return films;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des films:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer un film par son ID\n */\nexport const getFilmById = async (filmId: string): Promise<Film | null> => {\n  try {\n    const docRef = doc(db, FILMS_COLLECTION, filmId);\n    const docSnap = await getDoc(docRef);\n    \n    if (docSnap.exists()) {\n      const data = docSnap.data();\n      return {\n        id: docSnap.id,\n        titre: data.titre,\n        realisateur: data.realisateur,\n        pays: data.pays,\n        duree: data.duree,\n        annee: data.annee,\n        synopsis: data.synopsis,\n        posterUrl: data.posterUrl,\n        genre: data.genre,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      };\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Erreur lors de la récupération du film:', error);\n    throw error;\n  }\n};\n\n/**\n * Mettre à jour un film\n */\nexport const updateFilm = async (filmId: string, data: Partial<CreateFilmData>): Promise<void> => {\n  try {\n    const docRef = doc(db, FILMS_COLLECTION, filmId);\n    \n    const updateData: any = {\n      ...data,\n      updatedAt: new Date(),\n    };\n\n    // Upload du nouveau poster si fourni\n    if (data.poster) {\n      updateData.posterUrl = await uploadPoster(data.poster);\n    }\n\n    await updateDoc(docRef, updateData);\n  } catch (error) {\n    console.error('Erreur lors de la mise à jour du film:', error);\n    throw error;\n  }\n};\n\n/**\n * Supprimer un film\n */\nexport const deleteFilm = async (filmId: string): Promise<void> => {\n  try {\n    // Récupérer le film pour supprimer le poster\n    const film = await getFilmById(filmId);\n    if (film?.posterUrl) {\n      await deletePoster(film.posterUrl);\n    }\n\n    const docRef = doc(db, FILMS_COLLECTION, filmId);\n    await deleteDoc(docRef);\n  } catch (error) {\n    console.error('Erreur lors de la suppression du film:', error);\n    throw error;\n  }\n};\n\n/**\n * Upload d'un poster\n */\nexport const uploadPoster = async (file: File): Promise<string> => {\n  try {\n    const { storage } = await import('./firebase');\n    const fileName = `${generateId()}_${file.name}`;\n    const storageRef = ref(storage, `${POSTERS_FOLDER}/${fileName}`);\n    \n    const snapshot = await uploadBytes(storageRef, file);\n    const downloadURL = await getDownloadURL(snapshot.ref);\n    \n    return downloadURL;\n  } catch (error) {\n    console.error('Erreur lors de l\\'upload du poster:', error);\n    throw error;\n  }\n};\n\n/**\n * Supprimer un poster\n */\nexport const deletePoster = async (posterUrl: string): Promise<void> => {\n  try {\n    const { storage } = await import('./firebase');\n    const storageRef = ref(storage, posterUrl);\n    await deleteObject(storageRef);\n  } catch (error) {\n    console.error('Erreur lors de la suppression du poster:', error);\n    // Ne pas throw l'erreur car ce n'est pas critique\n  }\n};\n\n/**\n * Rechercher des films\n */\nexport const searchFilms = async (searchTerm: string): Promise<Film[]> => {\n  try {\n    const films = await getAllFilms();\n    const term = searchTerm.toLowerCase();\n    \n    return films.filter(film => \n      film.titre.toLowerCase().includes(term) ||\n      film.realisateur.toLowerCase().includes(term) ||\n      film.pays.toLowerCase().includes(term) ||\n      film.genre.toLowerCase().includes(term)\n    );\n  } catch (error) {\n    console.error('Erreur lors de la recherche de films:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les films par genre\n */\nexport const getFilmsByGenre = async (genre: string): Promise<Film[]> => {\n  try {\n    const q = query(\n      collection(db, FILMS_COLLECTION),\n      where('genre', '==', genre),\n      orderBy('titre', 'asc')\n    );\n    \n    const querySnapshot = await getDocs(q);\n    const films: Film[] = [];\n    \n    querySnapshot.forEach((doc) => {\n      const data = doc.data();\n      films.push({\n        id: doc.id,\n        titre: data.titre,\n        realisateur: data.realisateur,\n        pays: data.pays,\n        duree: data.duree,\n        annee: data.annee,\n        synopsis: data.synopsis,\n        posterUrl: data.posterUrl,\n        genre: data.genre,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n    \n    return films;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des films par genre:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les films récents\n */\nexport const getRecentFilms = async (limitCount: number = 10): Promise<Film[]> => {\n  try {\n    const q = query(\n      collection(db, FILMS_COLLECTION),\n      orderBy('createdAt', 'desc'),\n      limit(limitCount)\n    );\n    \n    const querySnapshot = await getDocs(q);\n    const films: Film[] = [];\n    \n    querySnapshot.forEach((doc) => {\n      const data = doc.data();\n      films.push({\n        id: doc.id,\n        titre: data.titre,\n        realisateur: data.realisateur,\n        pays: data.pays,\n        duree: data.duree,\n        annee: data.annee,\n        synopsis: data.synopsis,\n        posterUrl: data.posterUrl,\n        genre: data.genre,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n    \n    return films;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des films récents:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les statistiques des films\n */\nexport const getFilmsStats = async (): Promise<{\n  total: number;\n  parGenre: Record<string, number>;\n  parPays: Record<string, number>;\n  parAnnee: Record<number, number>;\n}> => {\n  try {\n    const films = await getAllFilms();\n    \n    const stats = {\n      total: films.length,\n      parGenre: {} as Record<string, number>,\n      parPays: {} as Record<string, number>,\n      parAnnee: {} as Record<number, number>,\n    };\n    \n    films.forEach(film => {\n      // Compter par genre\n      stats.parGenre[film.genre] = (stats.parGenre[film.genre] || 0) + 1;\n      \n      // Compter par pays\n      stats.parPays[film.pays] = (stats.parPays[film.pays] || 0) + 1;\n      \n      // Compter par année\n      stats.parAnnee[film.annee] = (stats.parAnnee[film.annee] || 0) + 1;\n    });\n    \n    return stats;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des statistiques des films:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les genres disponibles\n */\nexport const getAvailableGenres = async (): Promise<string[]> => {\n  try {\n    const films = await getAllFilms();\n    const genres = Array.from(new Set(films.map(film => film.genre)));\n    return genres.sort();\n  } catch (error) {\n    console.error('Erreur lors de la récupération des genres:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer plusieurs films par leurs IDs\n */\nexport const getFilmsByIds = async (filmIds: string[]): Promise<Film[]> => {\n  try {\n    if (filmIds.length === 0) return [];\n    \n    // Récupérer les films en parallèle\n    const filmPromises = filmIds.map(id => getFilmById(id));\n    const films = await Promise.all(filmPromises);\n    \n    // Filtrer les films null et retourner\n    return films.filter((film): film is Film => film !== null);\n  } catch (error) {\n    console.error('Erreur lors de la récupération des films par IDs:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les pays disponibles\n */\nexport const getAvailableCountries = async (): Promise<string[]> => {\n  try {\n    const films = await getAllFilms();\n    const countries = Array.from(new Set(films.map(film => film.pays)));\n    return countries.sort();\n  } catch (error) {\n    console.error('Erreur lors de la récupération des pays:', error);\n    throw error;\n  }\n}; ","import React from 'react';\r\nimport { cn } from '../../utils/helpers';\r\n\r\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\r\n  variant?: 'primary' | 'secondary' | 'outline' | 'ghost' | 'danger';\r\n  size?: 'sm' | 'md' | 'lg';\r\n  loading?: boolean;\r\n  icon?: React.ReactNode;\r\n  children: React.ReactNode;\r\n}\r\n\r\nexport const Button: React.FC<ButtonProps> = ({\r\n  variant = 'primary',\r\n  size = 'md',\r\n  loading = false,\r\n  icon,\r\n  children,\r\n  className,\r\n  disabled,\r\n  ...props\r\n}) => {\r\n  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-lg transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed';\r\n  \r\n  const variants = {\r\n    primary: 'bg-primary text-white hover:bg-primary-dark focus:ring-primary border-2 border-primary',\r\n    secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500',\r\n    outline: 'border-2 border-primary bg-white text-primary hover:bg-primary hover:text-white focus:ring-primary',\r\n    ghost: 'text-gray-700 hover:bg-gray-100 focus:ring-gray-500',\r\n    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',\r\n  };\r\n  \r\n  const sizes = {\r\n    sm: 'px-3 py-1.5 text-sm',\r\n    md: 'px-4 py-2 text-sm',\r\n    lg: 'px-6 py-3 text-base',\r\n  };\r\n  \r\n  return (\r\n    <button\r\n      className={cn(\r\n        baseClasses,\r\n        variants[variant],\r\n        sizes[size],\r\n        className\r\n      )}\r\n      disabled={disabled || loading}\r\n      {...props}\r\n    >\r\n      {loading && (\r\n        <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\">\r\n          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\r\n          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\r\n        </svg>\r\n      )}\r\n      {!loading && icon && <span className=\"mr-2\">{icon}</span>}\r\n      {children}\r\n    </button>\r\n  );\r\n}; ","import React from 'react';\r\nimport { cn } from '../../utils/helpers';\r\n\r\ninterface CardProps {\r\n  children: React.ReactNode;\r\n  className?: string;\r\n  padding?: 'none' | 'sm' | 'md' | 'lg';\r\n  shadow?: 'none' | 'sm' | 'md' | 'lg';\r\n}\r\n\r\nexport const Card: React.FC<CardProps> = ({\r\n  children,\r\n  className,\r\n  padding = 'md',\r\n  shadow = 'md',\r\n}) => {\r\n  const paddingClasses = {\r\n    none: '',\r\n    sm: 'p-4',\r\n    md: 'p-6',\r\n    lg: 'p-8',\r\n  };\r\n\r\n  const shadowClasses = {\r\n    none: '',\r\n    sm: 'shadow-sm',\r\n    md: 'shadow-md',\r\n    lg: 'shadow-lg',\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        'bg-white rounded-lg border border-gray-200',\r\n        paddingClasses[padding],\r\n        shadowClasses[shadow],\r\n        className\r\n      )}\r\n    >\r\n      {children}\r\n    </div>\r\n  );\r\n}; ","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Clock\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgLz4KICA8cG9seWxpbmUgcG9pbnRzPSIxMiA2IDEyIDEyIDE2IDE0IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/clock\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Clock = createLucideIcon('Clock', [\n  ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],\n  ['polyline', { points: '12 6 12 12 16 14', key: '68esgv' }],\n]);\n\nexport default Clock;\n","import {\n  collection,\n  doc,\n  deleteDoc,\n  getDocs,\n  query,\n  where,\n  orderBy,\n  onSnapshot,\n  writeBatch,\n  setDoc,\n} from 'firebase/firestore';\nimport { db } from './firebase';\nimport { Vote, VoteFormData } from '../types';\nimport { COLLECTIONS } from '../utils/constants';\nimport { generateId, generateSessionId, getUserAgent, getIpAddress } from '../utils/helpers';\n\n// Queue pour les votes en batch\nlet voteQueue: Vote[] = [];\nlet batchTimeout: number | null = null;\nlet isProcessingBatch = false;\n\n/**\n * Ajouter un vote directement (pour les séances)\n */\nexport const addVote = async (data: {\n  filmId: string;\n  seanceId?: string;\n  note: number;\n  commentaire?: string;\n}): Promise<void> => {\n  try {\n    const ipAddress = await getIpAddress();\n    const vote: Vote = {\n      id: generateId(),\n      filmId: data.filmId,\n      seanceId: data.seanceId || '',\n      note: data.note,\n      userAgent: getUserAgent(),\n      sessionId: generateSessionId(),\n      createdAt: new Date(),\n      ...(data.commentaire?.trim() && { commentaire: data.commentaire.trim() }),\n      ...(ipAddress && { ipAddress }),\n    };\n\n    // Ajouter directement à Firestore\n    const voteRef = doc(collection(db, COLLECTIONS.VOTES));\n    await setDoc(voteRef, {\n      ...vote,\n      id: voteRef.id,\n    } as any);\n  } catch (error: any) {\n    throw new Error('Erreur lors de l\\'ajout du vote');\n  }\n};\n\n/**\n * Ajouter un vote à la queue\n */\nexport const addVoteToQueue = async (\n  filmId: string,\n  data: VoteFormData,\n  user?: { uid: string; email: string } | null,\n  sessionId?: string\n): Promise<void> => {\n  try {\n    const ipAddress = await getIpAddress();\n    const vote: Vote = {\n      id: generateId(),\n      filmId,\n      seanceId: '',\n      note: data.note,\n      userAgent: getUserAgent(),\n      sessionId: sessionId || generateSessionId(),\n      createdAt: new Date(),\n      ...(data.commentaire?.trim() && { commentaire: data.commentaire.trim() }),\n      ...(ipAddress && { ipAddress }),\n    };\n\n    voteQueue.push(vote);\n\n    // Démarrer le timer pour l'envoi en batch\n    if (!batchTimeout) {\n      batchTimeout = window.setTimeout(() => {\n        processVoteBatch();\n      }, 5000); // 5 secondes de délai\n    }\n\n    // Vérifier si l'utilisateur a déjà voté pour ce film\n    const hasVoted = await checkIfUserVoted(filmId, user?.uid, sessionId);\n    if (hasVoted) {\n      throw new Error('Vous avez déjà voté pour ce film');\n    }\n  } catch (error: any) {\n    throw new Error(error.message || 'Erreur lors de l\\'ajout du vote');\n  }\n};\n\n/**\n * Traiter la queue de votes en batch\n */\nconst processVoteBatch = async (): Promise<void> => {\n  if (isProcessingBatch || voteQueue.length === 0) {\n    return;\n  }\n\n  isProcessingBatch = true;\n  const votesToProcess = [...voteQueue];\n  voteQueue = [];\n  batchTimeout = null;\n\n  try {\n    const batch = writeBatch(db);\n\n    // Ajouter tous les votes au batch\n    votesToProcess.forEach((vote) => {\n      const voteRef = doc(collection(db, COLLECTIONS.VOTES));\n      batch.set(voteRef, {\n        ...vote,\n        id: voteRef.id,\n      });\n    });\n\n    // Exécuter le batch\n    await batch.commit();\n\n    console.log(`${votesToProcess.length} votes envoyés avec succès`);\n  } catch (error) {\n    console.error('Erreur lors de l\\'envoi du batch:', error);\n    \n    // Remettre les votes dans la queue pour retry\n    voteQueue.unshift(...votesToProcess);\n    \n    // Retry après 10 secondes\n    setTimeout(() => {\n      isProcessingBatch = false;\n      if (voteQueue.length > 0) {\n        processVoteBatch();\n      }\n    }, 10000);\n  } finally {\n    isProcessingBatch = false;\n  }\n};\n\n/**\n * Vérifier si un utilisateur a déjà voté pour un film\n */\nexport const checkIfUserVoted = async (\n  filmId: string,\n  userId?: string,\n  sessionId?: string\n): Promise<boolean> => {\n  try {\n    let voteQuery;\n\n    if (userId) {\n      // Utilisateur connecté\n      voteQuery = query(\n        collection(db, COLLECTIONS.VOTES),\n        where('filmId', '==', filmId),\n        where('userId', '==', userId)\n      );\n    } else if (sessionId) {\n      // Vote anonyme\n      voteQuery = query(\n        collection(db, COLLECTIONS.VOTES),\n        where('filmId', '==', filmId),\n        where('sessionId', '==', sessionId)\n      );\n    } else {\n      return false;\n    }\n\n    const querySnapshot = await getDocs(voteQuery);\n    return !querySnapshot.empty;\n  } catch (error) {\n    console.error('Erreur lors de la vérification du vote:', error);\n    return false;\n  }\n};\n\n/**\n * Récupérer les votes d'un film\n */\nexport const getFilmVotes = async (filmId: string): Promise<Vote[]> => {\n  try {\n    const votesQuery = query(\n      collection(db, COLLECTIONS.VOTES),\n      where('filmId', '==', filmId),\n      orderBy('createdAt', 'desc')\n    );\n\n    const querySnapshot = await getDocs(votesQuery);\n    const votes: Vote[] = [];\n\n    querySnapshot.forEach((doc) => {\n      const voteData = doc.data();\n      votes.push({\n        ...voteData,\n        id: doc.id,\n        createdAt: voteData.createdAt?.toDate() || new Date(),\n      } as Vote);\n    });\n\n    return votes;\n  } catch (error: any) {\n    throw new Error('Erreur lors de la récupération des votes');\n  }\n};\n\n/**\n * Supprimer un vote\n */\nexport const deleteVote = async (voteId: string): Promise<void> => {\n  try {\n    await deleteDoc(doc(db, COLLECTIONS.VOTES, voteId));\n  } catch (error: any) {\n    throw new Error('Erreur lors de la suppression du vote');\n  }\n};\n\n/**\n * Récupérer les statistiques d'un film\n */\nexport const getFilmStats = async (filmId: string): Promise<{\n  filmId: string;\n  titre: string;\n  totalVotes: number;\n  moyenneNote: number;\n  distributionNotes: Record<number, number>;\n  commentaires: string[];\n}> => {\n  try {\n    const votes = await getFilmVotes(filmId);\n    const ratings = votes.map(vote => vote.note);\n    \n    const distribution: Record<number, number> = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n    ratings.forEach(rating => {\n      if (rating >= 1 && rating <= 5) {\n        distribution[rating]++;\n      }\n    });\n\n    const moyenne = ratings.length > 0 \n      ? Math.round((ratings.reduce((sum, r) => sum + r, 0) / ratings.length) * 10) / 10\n      : 0;\n\n    const commentaires = votes\n      .filter(vote => vote.commentaire)\n      .map(vote => vote.commentaire!)\n      .slice(0, 10); // Limiter à 10 commentaires\n\n    return {\n      filmId,\n      titre: '', // Sera rempli par l'appelant\n      totalVotes: votes.length,\n      moyenneNote: moyenne,\n      distributionNotes: distribution,\n      commentaires,\n    };\n  } catch (error: any) {\n    throw new Error('Erreur lors du calcul des statistiques');\n  }\n};\n\n/**\n * Écouter les changements de votes pour un film\n */\nexport const onVotesChange = (filmId: string, callback: (votes: Vote[]) => void) => {\n  const votesQuery = query(\n    collection(db, COLLECTIONS.VOTES),\n    where('filmId', '==', filmId),\n    orderBy('createdAt', 'desc')\n  );\n\n  return onSnapshot(votesQuery, (querySnapshot) => {\n    const votes: Vote[] = [];\n\n    querySnapshot.forEach((doc) => {\n      const voteData = doc.data();\n      votes.push({\n        ...voteData,\n        id: doc.id,\n        createdAt: voteData.createdAt?.toDate() || new Date(),\n      } as Vote);\n    });\n\n    callback(votes);\n  });\n};\n\n/**\n * Récupérer le statut de la queue de votes\n */\nexport const getVoteQueueStatus = () => {\n  return {\n    pendingVotes: voteQueue.length,\n    isProcessing: isProcessingBatch,\n    nextBatchIn: batchTimeout ? 5000 : 0,\n  };\n};\n\n/**\n * Forcer l'envoi immédiat de la queue\n */\nexport const forceProcessBatch = async (): Promise<void> => {\n  if (batchTimeout) {\n    clearTimeout(batchTimeout);\n    batchTimeout = null;\n  }\n  await processVoteBatch();\n};\n\n/**\n * Récupérer les résultats d'une séance\n */\nexport const getSeanceResults = async (seanceId: string): Promise<{\n  seanceId: string;\n  totalVotes: number;\n  films: Array<{\n    filmId: string;\n    titre: string;\n    totalVotes: number;\n    moyenneNote: number;\n    distributionNotes: Record<number, number>;\n  }>;\n}> => {\n  try {\n    // Récupérer tous les votes de la séance\n    const votesQuery = query(\n      collection(db, COLLECTIONS.VOTES),\n      where('seanceId', '==', seanceId),\n      orderBy('createdAt', 'desc')\n    );\n\n    const querySnapshot = await getDocs(votesQuery);\n    const votes: Vote[] = [];\n\n    querySnapshot.forEach((doc) => {\n      const voteData = doc.data();\n      votes.push({\n        ...voteData,\n        id: doc.id,\n        createdAt: voteData.createdAt?.toDate() || new Date(),\n      } as Vote);\n    });\n\n    // Grouper les votes par film\n    const filmVotes: Record<string, Vote[]> = {};\n    votes.forEach(vote => {\n      if (!filmVotes[vote.filmId]) {\n        filmVotes[vote.filmId] = [];\n      }\n      filmVotes[vote.filmId].push(vote);\n    });\n\n    // Calculer les statistiques pour chaque film\n    const films = Object.entries(filmVotes).map(([filmId, filmVotes]) => {\n      const ratings = filmVotes.map(vote => vote.note);\n      const distribution: Record<number, number> = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\n      \n      ratings.forEach(rating => {\n        if (rating >= 1 && rating <= 5) {\n          distribution[rating]++;\n        }\n      });\n\n      const moyenne = ratings.length > 0 \n        ? Math.round((ratings.reduce((sum, r) => sum + r, 0) / ratings.length) * 10) / 10\n        : 0;\n\n      return {\n        filmId,\n        titre: '', // Sera rempli par l'appelant\n        totalVotes: filmVotes.length,\n        moyenneNote: moyenne,\n        distributionNotes: distribution,\n      };\n    });\n\n    return {\n      seanceId,\n      totalVotes: votes.length,\n      films,\n    };\n  } catch (error: any) {\n    throw new Error('Erreur lors de la récupération des résultats de la séance');\n  }\n}; ","import { VALIDATION_RULES } from './constants';\r\n\r\n/**\r\n * Génère un ID unique\r\n */\r\nexport const generateId = (): string => {\r\n  return Date.now().toString(36) + Math.random().toString(36).substring(2);\r\n};\r\n\r\n/**\r\n * Génère un ID de session unique pour les votes anonymes\r\n */\r\nexport const generateSessionId = (): string => {\r\n  const timestamp = Date.now();\r\n  const random = Math.random().toString(36).substring(2);\r\n  return `${timestamp}-${random}`;\r\n};\r\n\r\n/**\r\n * Valide une adresse email\r\n */\r\nexport const isValidEmail = (email: string): boolean => {\r\n  return VALIDATION_RULES.EMAIL.test(email);\r\n};\r\n\r\n/**\r\n * Valide un mot de passe\r\n */\r\nexport const isValidPassword = (password: string): boolean => {\r\n  return password.length >= VALIDATION_RULES.PASSWORD_MIN_LENGTH;\r\n};\r\n\r\n/**\r\n * Valide un fichier image\r\n */\r\nexport const isValidImageFile = (file: File): boolean => {\r\n  return (\r\n    VALIDATION_RULES.ALLOWED_IMAGE_TYPES.indexOf(file.type) !== -1 &&\r\n    file.size <= VALIDATION_RULES.MAX_FILE_SIZE\r\n  );\r\n};\r\n\r\n/**\r\n * Redimensionne une image\r\n */\r\nexport const resizeImage = (\r\n  file: File,\r\n  maxWidth: number = 800,\r\n  maxHeight: number = 600,\r\n  quality: number = 0.8\r\n): Promise<Blob> => {\r\n  return new Promise((resolve, reject) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image();\r\n\r\n    img.onload = () => {\r\n      // Calculer les nouvelles dimensions\r\n      let { width, height } = img;\r\n      \r\n      if (width > maxWidth) {\r\n        height = (height * maxWidth) / width;\r\n        width = maxWidth;\r\n      }\r\n      \r\n      if (height > maxHeight) {\r\n        width = (width * maxHeight) / height;\r\n        height = maxHeight;\r\n      }\r\n\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n\r\n      if (ctx) {\r\n        ctx.drawImage(img, 0, 0, width, height);\r\n        canvas.toBlob(\r\n          (blob) => {\r\n            if (blob) {\r\n              resolve(blob);\r\n            } else {\r\n              reject(new Error('Erreur lors du redimensionnement'));\r\n            }\r\n          },\r\n          'image/jpeg',\r\n          quality\r\n        );\r\n      } else {\r\n        reject(new Error('Impossible de créer le contexte canvas'));\r\n      }\r\n    };\r\n\r\n    img.onerror = () => reject(new Error('Erreur lors du chargement de l\\'image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n};\r\n\r\n/**\r\n * Formate une date\r\n */\r\nexport const formatDate = (date: Date): string => {\r\n  return new Intl.DateTimeFormat('fr-FR', {\r\n    year: 'numeric',\r\n    month: 'long',\r\n    day: 'numeric',\r\n    hour: '2-digit',\r\n    minute: '2-digit',\r\n  }).format(date);\r\n};\r\n\r\n/**\r\n * Formate une note avec étoiles\r\n */\r\nexport const formatRating = (rating: number): string => {\r\n  return `${rating}/5`;\r\n};\r\n\r\n/**\r\n * Calcule la moyenne des notes\r\n */\r\nexport const calculateAverageRating = (ratings: number[]): number => {\r\n  if (ratings.length === 0) return 0;\r\n  const sum = ratings.reduce((acc, rating) => acc + rating, 0);\r\n  return Math.round((sum / ratings.length) * 10) / 10;\r\n};\r\n\r\n/**\r\n * Génère une distribution des notes\r\n */\r\nexport const generateRatingDistribution = (ratings: number[]): Record<number, number> => {\r\n  const distribution: Record<number, number> = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };\r\n  \r\n  ratings.forEach(rating => {\r\n    if (rating >= 1 && rating <= 5) {\r\n      distribution[rating]++;\r\n    }\r\n  });\r\n  \r\n  return distribution;\r\n};\r\n\r\n/**\r\n * Retourne l'User Agent du navigateur\r\n */\r\nexport const getUserAgent = (): string => {\r\n  return navigator.userAgent;\r\n};\r\n\r\n/**\r\n * Retourne l'adresse IP (approximative via service externe)\r\n */\r\nexport const getIpAddress = async (): Promise<string | null> => {\r\n  try {\r\n    const response = await fetch('https://api.ipify.org?format=json');\r\n    const data = await response.json();\r\n    return data.ip;\r\n  } catch (error) {\r\n    console.warn('Impossible de récupérer l\\'IP:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Stocke une valeur dans le localStorage\r\n */\r\nexport const setLocalStorage = (key: string, value: any): void => {\r\n  try {\r\n    localStorage.setItem(key, JSON.stringify(value));\r\n  } catch (error) {\r\n    console.warn('Erreur lors du stockage local:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Récupère une valeur du localStorage\r\n */\r\nexport const getLocalStorage = <T>(key: string, defaultValue: T): T => {\r\n  try {\r\n    const item = localStorage.getItem(key);\r\n    return item ? JSON.parse(item) : defaultValue;\r\n  } catch (error) {\r\n    console.warn('Erreur lors de la récupération locale:', error);\r\n    return defaultValue;\r\n  }\r\n};\r\n\r\n/**\r\n * Supprime une valeur du localStorage\r\n */\r\nexport const removeLocalStorage = (key: string): void => {\r\n  try {\r\n    localStorage.removeItem(key);\r\n  } catch (error) {\r\n    console.warn('Erreur lors de la suppression locale:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Débounce une fonction\r\n */\r\nexport const debounce = <T extends (...args: any[]) => any>(\r\n  func: T,\r\n  wait: number\r\n): ((...args: Parameters<T>) => void) => {\r\n  let timeout: number;\r\n  \r\n  return (...args: Parameters<T>) => {\r\n    clearTimeout(timeout);\r\n    timeout = window.setTimeout(() => func(...args), wait);\r\n  };\r\n};\r\n\r\n/**\r\n * Retry une fonction avec délai\r\n */\r\nexport const retry = async <T>(\r\n  fn: () => Promise<T>,\r\n  maxRetries: number = 3,\r\n  delay: number = 1000\r\n): Promise<T> => {\r\n  let lastError: Error = new Error('Une erreur est survenue');\r\n  \r\n  for (let i = 0; i < maxRetries; i++) {\r\n    try {\r\n      return await fn();\r\n    } catch (error) {\r\n      lastError = error as Error;\r\n      if (i < maxRetries - 1) {\r\n        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));\r\n      }\r\n    }\r\n  }\r\n  \r\n  throw new Error(lastError.message || 'Une erreur est survenue');\r\n};\r\n\r\n/**\r\n * Combine les classes CSS\r\n */\r\nexport const cn = (...classes: (string | undefined | null | false)[]): string => {\r\n  return classes.filter(Boolean).join(' ');\r\n}; ","import { db } from './firebase';\nimport { \n  collection, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc, \n  getDocs, \n  getDoc, \n  query, \n  where, \n  orderBy\n} from 'firebase/firestore';\n\nimport { Seance, CreateSeanceData, Film } from '../types';\nimport { generateId } from '../utils/helpers';\n\nconst SEANCES_COLLECTION = 'seances';\nconst FILMS_COLLECTION = 'films';\n\n/**\n * Créer une nouvelle séance avec génération automatique du QR code\n */\nexport const createSeance = async (data: CreateSeanceData): Promise<Seance> => {\n  try {\n    // Vérifier qu'il y a exactement 5 films\n    if (data.films.length !== 5) {\n      throw new Error('Une séance doit contenir exactement 5 films');\n    }\n\n    // Vérifier que tous les films existent\n    const filmsPromises = data.films.map(filmId => \n      getDoc(doc(db, FILMS_COLLECTION, filmId))\n    );\n    const filmsSnapshots = await Promise.all(filmsPromises);\n    \n    const nonExistentFilms = filmsSnapshots\n      .map((snapshot, index) => ({ snapshot, filmId: data.films[index] }))\n      .filter(({ snapshot }) => !snapshot.exists());\n    \n    if (nonExistentFilms.length > 0) {\n      throw new Error(`Films non trouvés: ${nonExistentFilms.map(f => f.filmId).join(', ')}`);\n    }\n\n    // Générer l'URL du QR code\n    const seanceId = generateId();\n    const qrCodeUrl = generateQRCodeUrl(seanceId);\n\n    const seanceData: Omit<Seance, 'id'> = {\n      nom: data.nom,\n      date: data.date,\n      heure: data.heure,\n      films: data.films,\n      qrCodeUrl,\n      isActive: true,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      ...(data.description && { description: data.description }),\n    };\n\n    const docRef = await addDoc(collection(db, SEANCES_COLLECTION), seanceData);\n    \n    return {\n      id: docRef.id,\n      ...seanceData,\n    };\n  } catch (error) {\n    console.error('Erreur lors de la création de la séance:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer toutes les séances\n */\nexport const getAllSeances = async (): Promise<Seance[]> => {\n  try {\n    const q = query(\n      collection(db, SEANCES_COLLECTION),\n      orderBy('date', 'desc')\n    );\n    \n    const querySnapshot = await getDocs(q);\n    const seances: Seance[] = [];\n    \n    querySnapshot.forEach((doc) => {\n      const data = doc.data();\n      seances.push({\n        id: doc.id,\n        nom: data.nom,\n        description: data.description,\n        date: data.date.toDate(),\n        heure: data.heure,\n        films: data.films,\n        qrCodeUrl: data.qrCodeUrl,\n        isActive: data.isActive,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n    \n    return seances;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des séances:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer une séance par son ID\n */\nexport const getSeanceById = async (seanceId: string): Promise<Seance | null> => {\n  try {\n    const docRef = doc(db, SEANCES_COLLECTION, seanceId);\n    const docSnap = await getDoc(docRef);\n    \n    if (docSnap.exists()) {\n      const data = docSnap.data();\n      return {\n        id: docSnap.id,\n        nom: data.nom,\n        description: data.description,\n        date: data.date.toDate(),\n        heure: data.heure,\n        films: data.films,\n        qrCodeUrl: data.qrCodeUrl,\n        isActive: data.isActive,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      };\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Erreur lors de la récupération de la séance:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer une séance avec ses films\n */\nexport const getSeanceWithFilms = async (seanceId: string): Promise<{ seance: Seance; films: Film[] } | null> => {\n  try {\n    const seance = await getSeanceById(seanceId);\n    if (!seance) return null;\n\n    // Récupérer tous les films de la séance\n    const filmsPromises = seance.films.map(filmId => \n      getDoc(doc(db, FILMS_COLLECTION, filmId))\n    );\n    const filmsSnapshots = await Promise.all(filmsPromises);\n    \n    const films: Film[] = [];\n    \n    for (const snapshot of filmsSnapshots) {\n      if (snapshot.exists()) {\n        const data = snapshot.data();\n        if (data) {\n          films.push({\n            id: snapshot.id,\n            titre: data.titre,\n            realisateur: data.realisateur,\n            pays: data.pays,\n            duree: data.duree,\n            annee: data.annee,\n            synopsis: data.synopsis,\n            posterUrl: data.posterUrl,\n            genre: data.genre,\n            createdAt: data.createdAt.toDate(),\n            updatedAt: data.updatedAt.toDate(),\n          });\n        }\n      }\n    }\n\n    return { seance, films };\n  } catch (error) {\n    console.error('Erreur lors de la récupération de la séance avec films:', error);\n    throw error;\n  }\n};\n\n/**\n * Mettre à jour une séance\n */\nexport const updateSeance = async (seanceId: string, data: Partial<CreateSeanceData>): Promise<void> => {\n  try {\n    const docRef = doc(db, SEANCES_COLLECTION, seanceId);\n    \n    const updateData: any = {\n      ...data,\n      updatedAt: new Date(),\n    };\n\n    // Si les films changent, vérifier qu'il y en a 5\n    if (data.films && data.films.length !== 5) {\n      throw new Error('Une séance doit contenir exactement 5 films');\n    }\n\n    await updateDoc(docRef, updateData);\n  } catch (error) {\n    console.error('Erreur lors de la mise à jour de la séance:', error);\n    throw error;\n  }\n};\n\n/**\n * Supprimer une séance\n */\nexport const deleteSeance = async (seanceId: string): Promise<void> => {\n  try {\n    const docRef = doc(db, SEANCES_COLLECTION, seanceId);\n    await deleteDoc(docRef);\n  } catch (error) {\n    console.error('Erreur lors de la suppression de la séance:', error);\n    throw error;\n  }\n};\n\n/**\n * Activer/désactiver une séance\n */\nexport const toggleSeanceActive = async (seanceId: string, isActive: boolean): Promise<void> => {\n  try {\n    const docRef = doc(db, SEANCES_COLLECTION, seanceId);\n    await updateDoc(docRef, {\n      isActive,\n      updatedAt: new Date(),\n    });\n  } catch (error) {\n    console.error('Erreur lors de la modification du statut de la séance:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupérer les séances actives\n */\nexport const getActiveSeances = async (): Promise<Seance[]> => {\n  try {\n    const q = query(\n      collection(db, SEANCES_COLLECTION),\n      where('isActive', '==', true),\n      orderBy('date', 'desc')\n    );\n    \n    const querySnapshot = await getDocs(q);\n    const seances: Seance[] = [];\n    \n    querySnapshot.forEach((doc) => {\n      const data = doc.data();\n      seances.push({\n        id: doc.id,\n        nom: data.nom,\n        description: data.description,\n        date: data.date.toDate(),\n        heure: data.heure,\n        films: data.films,\n        qrCodeUrl: data.qrCodeUrl,\n        isActive: data.isActive,\n        createdAt: data.createdAt.toDate(),\n        updatedAt: data.updatedAt.toDate(),\n      });\n    });\n    \n    return seances;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des séances actives:', error);\n    throw error;\n  }\n};\n\n/**\n * Générer l'URL du QR code pour une séance\n */\nexport const generateQRCodeUrl = (seanceId: string): string => {\n  const baseUrl = window.location.origin;\n  const seanceUrl = `${baseUrl}/seance/${seanceId}`;\n  \n  // Utiliser un service de génération de QR code\n  const qrServiceUrl = 'https://api.qrserver.com/v1/create-qr-code/';\n  const params = new URLSearchParams({\n    size: '300x300',\n    data: seanceUrl,\n    format: 'png',\n  });\n  \n  return `${qrServiceUrl}?${params.toString()}`;\n};\n\n/**\n * Récupérer les statistiques des séances\n */\nexport const getSeancesStats = async (): Promise<{\n  total: number;\n  actives: number;\n  inactives: number;\n  cetteSemaine: number;\n}> => {\n  try {\n    const seances = await getAllSeances();\n    const maintenant = new Date();\n    const uneSemaine = new Date(maintenant.getTime() + 7 * 24 * 60 * 60 * 1000);\n    \n    const stats = {\n      total: seances.length,\n      actives: seances.filter(s => s.isActive).length,\n      inactives: seances.filter(s => !s.isActive).length,\n      cetteSemaine: seances.filter(s => s.date >= maintenant && s.date <= uneSemaine).length,\n    };\n    \n    return stats;\n  } catch (error) {\n    console.error('Erreur lors de la récupération des statistiques:', error);\n    throw error;\n  }\n};\n\n/**\n * Rechercher des séances par nom\n */\nexport const searchSeances = async (searchTerm: string): Promise<Seance[]> => {\n  try {\n    const seances = await getAllSeances();\n    const term = searchTerm.toLowerCase();\n    \n    return seances.filter(seance => \n      seance.nom.toLowerCase().includes(term) ||\n      (seance.description && seance.description.toLowerCase().includes(term))\n    );\n  } catch (error) {\n    console.error('Erreur lors de la recherche de séances:', error);\n    throw error;\n  }\n}; "],"names":["FILMS_COLLECTION","getAllFilms","async","q","query","collection","db","orderBy","querySnapshot","getDocs","films","forEach","doc","data","push","id","titre","realisateur","pays","duree","annee","synopsis","posterUrl","genre","createdAt","toDate","updatedAt","error","console","getFilmById","docRef","filmId","docSnap","getDoc","exists","getFilmsByIds","filmIds","length","filmPromises","map","Promise","all","filter","film","Button","_ref","variant","size","loading","icon","children","className","disabled","props","_jsxs","cn","primary","secondary","outline","ghost","danger","sm","md","lg","fill","viewBox","_jsx","cx","cy","r","stroke","strokeWidth","d","Card","padding","shadow","none","Clock","createLucideIcon","key","points","voteQueue","batchTimeout","isProcessingBatch","addVote","_data$commentaire","ipAddress","getIpAddress","vote","generateId","seanceId","note","userAgent","getUserAgent","sessionId","generateSessionId","Date","commentaire","trim","voteRef","COLLECTIONS","VOTES","setDoc","Error","addVoteToQueue","user","_data$commentaire2","window","setTimeout","processVoteBatch","checkIfUserVoted","uid","message","votesToProcess","batch","writeBatch","set","commit","log","unshift","userId","voteQuery","where","empty","getVoteQueueStatus","pendingVotes","isProcessing","nextBatchIn","getSeanceResults","votesQuery","votes","_voteData$createdAt3","voteData","filmVotes","Object","entries","ratings","distribution","rating","moyenne","Math","round","reduce","sum","totalVotes","moyenneNote","distributionNotes","now","toString","random","substring","navigator","response","fetch","json","ip","warn","setLocalStorage","value","localStorage","setItem","JSON","stringify","getLocalStorage","defaultValue","item","getItem","parse","_len2","arguments","classes","Array","_key2","Boolean","join","SEANCES_COLLECTION","createSeance","filmsPromises","nonExistentFilms","snapshot","index","f","qrCodeUrl","generateQRCodeUrl","seanceData","nom","date","heure","isActive","description","addDoc","getAllSeances","seances","getSeanceById","updateSeance","updateData","updateDoc","deleteSeance","deleteDoc","toggleSeanceActive","baseUrl","location","origin","URLSearchParams","format"],"sourceRoot":""}